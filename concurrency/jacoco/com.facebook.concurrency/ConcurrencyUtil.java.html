<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ConcurrencyUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcommon concurrency</a> &gt; <a href="index.html" class="el_package">com.facebook.concurrency</a> &gt; <span class="el_source">ConcurrencyUtil.java</span></div><h1>ConcurrencyUtil.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.concurrency;

import com.facebook.util.ExtRunnable;
import com.facebook.util.exceptions.ExceptionHandler;
import com.google.common.base.Function;
import com.google.common.collect.Iterators;
import org.apache.log4j.Logger;

import java.util.Iterator;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * This is a helper class for running tasks in parallel. It uses a static, shared thread pool.
 * ParallelRunner is preferred for at least two reasons:
 *
 * 1. In a system that attempts to bound resources with executors, a ParallelExecutor may wrap
 * a bounded Executor and still respect those bounds. This has its own unbounded thread pool
 * and will never say no to any number of threads (ex: a call to parallelRun() asking for 100
 * threads gets it here no matter what, but ParallelRunner may be on an Executor
 * that bounds threads to 50, and 50 will be the actual limit
 *
 * 2. testing is much easier as you can put in MockExecutor
 *
 * This is useful in prototyping parallelism to see if it help.  See ParallelRunner's method
 * javadocs
 *
 */
<span class="nc" id="L49">public class ConcurrencyUtil {</span>
<span class="nc" id="L50">  private static final Logger LOG = Logger.getLogger(ConcurrencyUtil.class);</span>
<span class="nc" id="L51">  private static final AtomicLong INSTANCE_NUMBER = new AtomicLong(0);</span>
<span class="nc" id="L52">  private static final ReadWriteLock SHUTDOWN_LOCK =</span>
    new ReentrantReadWriteLock();
<span class="nc" id="L54">  private static final ExecutorService CACHED_EXECUTOR =</span>
    Executors.newCachedThreadPool();
<span class="nc" id="L56">  private static final ParallelRunner PARALLEL_RUNNER = new ParallelRunner(</span>
    CACHED_EXECUTOR, &quot;ParallelRunExt-&quot;
  );
  private static final int AWAIT_TERMINATION_SECONDS = 30;

  static {
<span class="nc" id="L62">    Runtime.getRuntime().addShutdownHook(</span>
      new Thread(
<span class="nc" id="L64">        new Runnable() {</span>
          @Override
          public void run() {
<span class="nc" id="L67">            SHUTDOWN_LOCK.writeLock().lock();</span>

            try {
<span class="nc" id="L70">              CACHED_EXECUTOR.shutdown();</span>
            } finally {
<span class="nc" id="L72">              SHUTDOWN_LOCK.writeLock().unlock();</span>
<span class="nc" id="L73">            }</span>
<span class="nc" id="L74">          }</span>
        }
      )
    );
<span class="nc" id="L78">  }</span>


  public static Runnable shutdownExecutorTask(final ExecutorService executor) {
<span class="nc" id="L82">    return new Runnable() {</span>
      @Override
      public void run() {
        try {
<span class="nc" id="L86">          executor.shutdown();</span>
<span class="nc bnc" id="L87" title="All 2 branches missed.">          if (!executor.awaitTermination(AWAIT_TERMINATION_SECONDS, TimeUnit.SECONDS)) {</span>
<span class="nc" id="L88">            LOG.warn(</span>
              String.format(
                &quot;executor didn't finish shutting down in %d seconds, moving on&quot;,
                AWAIT_TERMINATION_SECONDS
              )
            );
          }
<span class="nc" id="L95">        } catch (InterruptedException e) {</span>
<span class="nc" id="L96">          LOG.warn(&quot;interrupted shutting down executor&quot;);</span>
<span class="nc" id="L97">        }</span>
<span class="nc" id="L98">      }</span>
    };
  }

  public static &lt;E extends Exception&gt; void parallelRunExt(
    Iterable&lt;? extends ExtRunnable&lt;E&gt;&gt; tasks,
    int numThreads,
    final ExceptionHandler&lt;E&gt; exceptionHandler
  ) throws E {
<span class="nc" id="L107">    parallelRunExt(tasks.iterator(), numThreads, exceptionHandler);</span>
<span class="nc" id="L108">  }</span>
  
  public static &lt;E extends Exception&gt; void parallelRunExt(
    Iterator&lt;? extends ExtRunnable&lt;E&gt;&gt; tasksIter,
    int numThreads,
    final ExceptionHandler&lt;E&gt; exceptionHandler
  ) throws E {
<span class="nc" id="L115">    parallelRunExt(</span>
      tasksIter,
      numThreads,
      exceptionHandler,
      &quot;ParallelRunExt-&quot; + INSTANCE_NUMBER.getAndIncrement()
    );
<span class="nc" id="L121">  }</span>

  public static &lt;E extends Exception&gt; void parallelRunExt(
    Iterable&lt;? extends ExtRunnable&lt;E&gt;&gt; tasks,
    int numThreads,
    final ExceptionHandler&lt;E&gt; exceptionHandler,
    String baseName
  ) throws E {
<span class="nc" id="L129">    parallelRunExt(tasks.iterator(), numThreads, exceptionHandler, baseName);</span>
<span class="nc" id="L130">  }</span>
  
  public static &lt;E extends Exception&gt; void parallelRunExt(
    Iterator&lt;? extends ExtRunnable&lt;E&gt;&gt; tasksIter,
    int numThreads,
    final ExceptionHandler&lt;E&gt; exceptionHandler,
    String baseName
  ) throws E {
<span class="nc" id="L138">    final AtomicReference&lt;E&gt; exception = new AtomicReference&lt;E&gt;();</span>
<span class="nc" id="L139">    Iterator&lt;Runnable&gt; wrappedIterator = Iterators.transform(</span>
<span class="nc" id="L140">      tasksIter, new Function&lt;ExtRunnable&lt;E&gt;, Runnable&gt;() {</span>
      @Override
      public Runnable apply(final ExtRunnable&lt;E&gt; task) {
<span class="nc" id="L143">        return new Runnable() {</span>
          @Override
          public void run() {
            try {
              // short-circuit if other tasksIter failed
<span class="nc bnc" id="L148" title="All 2 branches missed.">              if (exception.get() == null) {</span>
<span class="nc" id="L149">                task.run();</span>
              }
<span class="nc" id="L151">            } catch (Exception e) {</span>
<span class="nc" id="L152">              exception.compareAndSet(null, exceptionHandler.handle(e));</span>
<span class="nc" id="L153">            }</span>
<span class="nc" id="L154">          }</span>
        };
      }
    }
    );

<span class="nc" id="L160">    parallelRun(wrappedIterator, numThreads, baseName);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">    if (exception.get() != null) {</span>
<span class="nc" id="L163">      throw exception.get();</span>
    }
<span class="nc" id="L165">  }</span>

  public static void parallelRun(Iterable&lt;? extends Runnable&gt; tasks, int numThreads) {
<span class="nc" id="L168">    parallelRun(tasks.iterator(), numThreads);</span>
<span class="nc" id="L169">  }</span>
  
  public static void parallelRun(Iterator&lt;? extends Runnable&gt; tasksIter, int numThreads) {
<span class="nc" id="L172">    parallelRun(</span>
      tasksIter, numThreads, &quot;ParallelRun-&quot; + INSTANCE_NUMBER.getAndIncrement()
    );
<span class="nc" id="L175">  }</span>

  public static void parallelRun(
    Iterable&lt;? extends Runnable&gt; tasks, int numThreads, String baseName
  ) {
<span class="nc" id="L180">    parallelRun(tasks.iterator(), numThreads, baseName);</span>
<span class="nc" id="L181">  }</span>
  
  public static void parallelRun(
    Iterator&lt;? extends Runnable&gt; tasksIter, int numThreads, String baseName
  ) {
    ParallelRunner parallelRunner;

    // make sure the cached executor cannot be shutdown while we use it
<span class="nc" id="L189">    SHUTDOWN_LOCK.readLock().lock();</span>

    try {
<span class="nc bnc" id="L192" title="All 2 branches missed.">      if (!CACHED_EXECUTOR.isShutdown()) {</span>
        // we can use the runner that wraps CACHED_EXECUTOR
<span class="nc" id="L194">        PARALLEL_RUNNER.parallelRun(tasksIter, numThreads, baseName);</span>
      } else {
        // we have to create a one-off for this run
<span class="nc" id="L197">        ExecutorService executor = Executors.newFixedThreadPool(numThreads);</span>
        
<span class="nc" id="L199">        parallelRunner = new ParallelRunner(</span>
          executor,
          &quot;ParallelRunExt-&quot;
        );
<span class="nc" id="L203">        parallelRunner.parallelRun(tasksIter, numThreads, baseName);</span>
<span class="nc" id="L204">        executor.shutdown();</span>
      }
    } finally {
<span class="nc" id="L207">      SHUTDOWN_LOCK.readLock().unlock();</span>
<span class="nc" id="L208">    }</span>
<span class="nc" id="L209">  }</span>

  public static void shutdown() {
<span class="nc" id="L212">    SHUTDOWN_LOCK.writeLock().lock();</span>
    
    try {
<span class="nc" id="L215">      CACHED_EXECUTOR.shutdown();</span>
    } finally {
<span class="nc" id="L217">      SHUTDOWN_LOCK.writeLock().unlock();</span>
<span class="nc" id="L218">    }</span>
<span class="nc" id="L219">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>