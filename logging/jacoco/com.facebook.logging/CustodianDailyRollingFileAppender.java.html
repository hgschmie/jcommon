<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CustodianDailyRollingFileAppender.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcommon logging</a> &gt; <a href="index.html" class="el_package">com.facebook.logging</a> &gt; <span class="el_source">CustodianDailyRollingFileAppender.java</span></div><h1>CustodianDailyRollingFileAppender.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.logging;

/**
 * CustodianDailyRollingFileAppender.java
 * Adapted from the Apache Log4j DailyRollingFileAppender to extend the functionality
 * of the existing class so that the user can limit the number of log backups
 * and compress the backups to conserve disk space.
 * @author Ryan Kimber

 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.File;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.Locale;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

//We have to import the log4j package because this class used to be in it and references other classes in that package.
import org.apache.log4j.*;
import org.apache.log4j.helpers.LogLog;
import org.apache.log4j.spi.LoggingEvent;

/**
 * CustodianDailyRollingFileAppender is based on
 * {@link org.apache.log4j.appender.DailyRollingFileAppender} so most of the
 * configuration options can be taken from the documentation on that class.
 */
public class CustodianDailyRollingFileAppender extends FileAppender
{
	// The code assumes that the following constants are in a increasing
	// sequence.
	static final int TOP_OF_TROUBLE = -1;
	static final int TOP_OF_MINUTE = 0;
	static final int TOP_OF_HOUR = 1;
	static final int HALF_DAY = 2;
	static final int TOP_OF_DAY = 3;
	static final int TOP_OF_WEEK = 4;
	static final int TOP_OF_MONTH = 5;

	/**
	 * The date pattern. By default, the pattern is set to &quot;'.'yyyy-MM-dd&quot;
	 * meaning daily rollover.
	 */
<span class="nc" id="L81">	private String datePattern = &quot;'.'yyyy-MM-dd&quot;;</span>
<span class="nc" id="L82">	private String compressBackups = &quot;false&quot;;</span>
<span class="nc" id="L83">	private String maxNumberOfDays = &quot;7&quot;;</span>

	/**
	 * The log file will be renamed to the value of the scheduledFilename
	 * variable when the next interval is entered. For example, if the rollover
	 * period is one hour, the log file will be renamed to the value of
	 * &quot;scheduledFilename&quot; at the beginning of the next hour.
	 * 
	 * The precise time when a rollover occurs depends on logging activity.
	 */
	private String scheduledFilename;

	/**
	 * The next time we estimate a rollover should occur.
	 */
<span class="nc" id="L98">	private long nextCheck = System.currentTimeMillis() - 1;</span>

<span class="nc" id="L100">	Date now = new Date();</span>

	SimpleDateFormat sdf;

<span class="nc" id="L104">	RollingCalendar rc = new RollingCalendar();</span>

<span class="nc" id="L106">	int checkPeriod = TOP_OF_TROUBLE;</span>

	// The gmtTimeZone is used only in computeCheckPeriod() method.
<span class="nc" id="L109">	static final TimeZone gmtTimeZone = TimeZone.getTimeZone(&quot;GMT&quot;);</span>

	/**
	 * The default constructor does nothing.
	 */
	public CustodianDailyRollingFileAppender()
<span class="nc" id="L115">	{</span>
<span class="nc" id="L116">	}</span>

	/**
	 * Instantiate a CustodianDailyRollingFileAppender and open the file
	 * designated by filename. The opened filename will become the ouput
	 * destination for this appender.
	 */
	public CustodianDailyRollingFileAppender(Layout layout, String filename,
			String datePattern) throws IOException
	{
<span class="nc" id="L126">		super(layout, filename, true);</span>
<span class="nc" id="L127">		this.datePattern = datePattern;</span>
<span class="nc" id="L128">		activateOptions();</span>
<span class="nc" id="L129">	}</span>

	/**
	 * The DatePattern takes a string in the same format as expected by
	 * {@link SimpleDateFormat}. This options determines the rollover schedule.
	 */
	public void setDatePattern(String pattern)
	{
<span class="nc" id="L137">		datePattern = pattern;</span>
<span class="nc" id="L138">	}</span>

	/** Returns the value of the DatePattern option. */
	public String getDatePattern()
	{
<span class="nc" id="L143">		return datePattern;</span>
	}

	public void activateOptions()
	{
<span class="nc" id="L148">		super.activateOptions();</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">		if (datePattern != null &amp;&amp; fileName != null)</span>
		{
<span class="nc" id="L151">			now.setTime(System.currentTimeMillis());</span>
<span class="nc" id="L152">			sdf = new SimpleDateFormat(datePattern);</span>
<span class="nc" id="L153">			int type = computeCheckPeriod();</span>
<span class="nc" id="L154">			printPeriodicity(type);</span>
<span class="nc" id="L155">			rc.setType(type);</span>
<span class="nc" id="L156">			File file = new File(fileName);</span>
<span class="nc" id="L157">			scheduledFilename = fileName</span>
					+ sdf.format(new Date(file.lastModified()));

<span class="nc" id="L160">		} else</span>
		{
<span class="nc" id="L162">			LogLog</span>
					.error(&quot;Either File or DatePattern options are not set for appender [&quot;
							+ name + &quot;].&quot;);
		}
<span class="nc" id="L166">	}</span>

	void printPeriodicity(int type)
	{
<span class="nc bnc" id="L170" title="All 7 branches missed.">		switch (type)</span>
		{
		case TOP_OF_MINUTE:
<span class="nc" id="L173">			LogLog.debug(&quot;Appender [&quot; + name + &quot;] to be rolled every minute.&quot;);</span>
<span class="nc" id="L174">			break;</span>
		case TOP_OF_HOUR:
<span class="nc" id="L176">			LogLog.debug(&quot;Appender [&quot; + name</span>
					+ &quot;] to be rolled on top of every hour.&quot;);
<span class="nc" id="L178">			break;</span>
		case HALF_DAY:
<span class="nc" id="L180">			LogLog.debug(&quot;Appender [&quot; + name</span>
					+ &quot;] to be rolled at midday and midnight.&quot;);
<span class="nc" id="L182">			break;</span>
		case TOP_OF_DAY:
<span class="nc" id="L184">			LogLog.debug(&quot;Appender [&quot; + name + &quot;] to be rolled at midnight.&quot;);</span>
<span class="nc" id="L185">			break;</span>
		case TOP_OF_WEEK:
<span class="nc" id="L187">			LogLog.debug(&quot;Appender [&quot; + name</span>
					+ &quot;] to be rolled at start of week.&quot;);
<span class="nc" id="L189">			break;</span>
		case TOP_OF_MONTH:
<span class="nc" id="L191">			LogLog.debug(&quot;Appender [&quot; + name</span>
					+ &quot;] to be rolled at start of every month.&quot;);
<span class="nc" id="L193">			break;</span>
		default:
<span class="nc" id="L195">			LogLog.warn(&quot;Unknown periodicity for appender [&quot; + name + &quot;].&quot;);</span>
		}
<span class="nc" id="L197">	}</span>

	// This method computes the roll over period by looping over the
	// periods, starting with the shortest, and stopping when the r0 is
	// different from from r1, where r0 is the epoch formatted according
	// the datePattern (supplied by the user) and r1 is the
	// epoch+nextMillis(i) formatted according to datePattern. All date
	// formatting is done in GMT and not local format because the test
	// logic is based on comparisons relative to 1970-01-01 00:00:00
	// GMT (the epoch).

	int computeCheckPeriod()
	{
<span class="nc" id="L210">		RollingCalendar rollingCalendar = new RollingCalendar(gmtTimeZone,</span>
				Locale.ENGLISH);
		// set sate to 1970-01-01 00:00:00 GMT
<span class="nc" id="L213">		Date epoch = new Date(0);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (datePattern != null)</span>
		{
<span class="nc bnc" id="L216" title="All 2 branches missed.">			for (int i = TOP_OF_MINUTE; i &lt;= TOP_OF_MONTH; i++)</span>
			{
<span class="nc" id="L218">				SimpleDateFormat simpleDateFormat = new SimpleDateFormat(</span>
						datePattern);
<span class="nc" id="L220">				simpleDateFormat.setTimeZone(gmtTimeZone); // do all date</span>
				// formatting in GMT
<span class="nc" id="L222">				String r0 = simpleDateFormat.format(epoch);</span>
<span class="nc" id="L223">				rollingCalendar.setType(i);</span>
<span class="nc" id="L224">				Date next = new Date(rollingCalendar.getNextCheckMillis(epoch));</span>
<span class="nc" id="L225">				String r1 = simpleDateFormat.format(next);</span>
				// System.out.println(&quot;Type = &quot;+i+&quot;, r0 = &quot;+r0+&quot;, r1 = &quot;+r1);
<span class="nc bnc" id="L227" title="All 6 branches missed.">				if (r0 != null &amp;&amp; r1 != null &amp;&amp; !r0.equals(r1))</span>
				{
<span class="nc" id="L229">					return i;</span>
				}
			}
		}
<span class="nc" id="L233">		return TOP_OF_TROUBLE; // Deliberately head for trouble...</span>
	}

	/**
	 * Rollover the current file to a new file.
	 */
	void rollOver() throws IOException
	{

		/* Compute filename, but only if datePattern is specified */
<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (datePattern == null)</span>
		{
<span class="nc" id="L245">			errorHandler.error(&quot;Missing DatePattern option in rollOver().&quot;);</span>
<span class="nc" id="L246">			return;</span>
		}

<span class="nc" id="L249">		String datedFilename = fileName + sdf.format(now);</span>
		// It is too early to roll over because we are still within the
		// bounds of the current interval. Rollover will occur once the
		// next interval is reached.
<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (scheduledFilename.equals(datedFilename))</span>
		{
<span class="nc" id="L255">			return;</span>
		}

		// close current file, and rename it to datedFilename
<span class="nc" id="L259">		this.closeFile();</span>

<span class="nc" id="L261">		File target = new File(scheduledFilename);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">		if (target.exists())</span>
		{
<span class="nc" id="L264">			target.delete();</span>
		}

<span class="nc" id="L267">		File file = new File(fileName);</span>
<span class="nc" id="L268">		boolean result = file.renameTo(target);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (result)</span>
		{
<span class="nc" id="L271">			LogLog.debug(fileName + &quot; -&gt; &quot; + scheduledFilename);</span>
		} else
		{
<span class="nc" id="L274">			LogLog.error(&quot;Failed to rename [&quot; + fileName + &quot;] to [&quot;</span>
					+ scheduledFilename + &quot;].&quot;);
		}

		try
		{
			// This will also close the file. This is OK since multiple
			// close operations are safe.
<span class="nc" id="L282">			this.setFile(fileName, false, this.bufferedIO, this.bufferSize);</span>
<span class="nc" id="L283">		} catch (IOException e)</span>
		{
<span class="nc" id="L285">			errorHandler.error(&quot;setFile(&quot; + fileName + &quot;, false) call failed.&quot;);</span>
<span class="nc" id="L286">		}</span>
<span class="nc" id="L287">		scheduledFilename = datedFilename;</span>
<span class="nc" id="L288">	}</span>

	/**
	 * This method differentiates DailyRollingFileAppender from its super class.
	 * 
	 * 
	 * Before actually logging, this method will check whether it is time to do
	 * a rollover. If it is, it will schedule the next rollover time and then
	 * rollover.
	 * */
	protected void subAppend(LoggingEvent event)
	{
<span class="nc" id="L300">		long n = System.currentTimeMillis();</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">		if (n &gt;= nextCheck)</span>
		{
<span class="nc" id="L303">			now.setTime(n);</span>
<span class="nc" id="L304">			nextCheck = rc.getNextCheckMillis(now);</span>
			try
			{
<span class="nc" id="L307">				cleanupAndRollOver();</span>
			} 
<span class="nc" id="L309">			catch (IOException ioe)</span>
			{
<span class="nc" id="L311">				LogLog.error(&quot;cleanupAndRollover() failed.&quot;, ioe);</span>
<span class="nc" id="L312">			}</span>
		}
<span class="nc" id="L314">		super.subAppend(event);</span>
<span class="nc" id="L315">	}</span>

	public String getCompressBackups()
	{
<span class="nc" id="L319">		return compressBackups;</span>
	}

	public void setCompressBackups(String compressBackups)
	{
<span class="nc" id="L324">		this.compressBackups = compressBackups;</span>
<span class="nc" id="L325">	}</span>

	public String getMaxNumberOfDays()
	{
<span class="nc" id="L329">		return maxNumberOfDays;</span>
	}

	public void setMaxNumberOfDays(String maxNumberOfDays)
	{
<span class="nc" id="L334">		this.maxNumberOfDays = maxNumberOfDays;</span>
<span class="nc" id="L335">	}</span>

	/*
	 * This method checks to see if we're exceeding the number of log backups
	 * that we are supposed to keep, and if so, deletes the offending files. It
	 * then delegates to the rollover method to rollover to a new file if
	 * required.
	 */
	protected void cleanupAndRollOver() throws IOException
	{
		// Check to see if there are already 5 files
<span class="nc" id="L346">		File file = new File(fileName);</span>
<span class="nc" id="L347">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L348">		int maxDays = 7;</span>
		try
		{
<span class="nc" id="L351">			maxDays = Integer.parseInt(getMaxNumberOfDays());</span>
<span class="nc" id="L352">		} catch (Exception e)</span>
		{
			// just leave it at 7.
<span class="nc" id="L355">		}</span>
<span class="nc" id="L356">		cal.add(Calendar.DATE, -maxDays);</span>
<span class="nc" id="L357">		Date cutoffDate = cal.getTime();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (file.getParentFile().exists())</span>
		{
<span class="nc" id="L360">			File[] files = file.getParentFile().listFiles(</span>
					new StartsWithFileFilter(file.getName(), false));
<span class="nc" id="L362">			int nameLength = file.getName().length();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">			for (int i = 0; i &lt; files.length; i++)</span>
			{
<span class="nc" id="L365">				String datePart = null;</span>
				try
				{
<span class="nc" id="L368">					datePart = files[i].getName().substring(nameLength);</span>
<span class="nc" id="L369">					Date date = sdf.parse(datePart);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">					if (date.before(cutoffDate))</span>
					{
<span class="nc" id="L372">						files[i].delete();</span>
					}
					//If we're supposed to zip files and this isn't already a zip
<span class="nc bnc" id="L375" title="All 4 branches missed.">          else if(getCompressBackups().equalsIgnoreCase(&quot;YES&quot;) || getCompressBackups().equalsIgnoreCase(&quot;TRUE&quot;))</span>
          {
<span class="nc" id="L377">            zipAndDelete(files[i]);</span>
          }
				} 
<span class="nc" id="L380">				catch (Exception pe)</span>
				{
					// This isn't a file we should touch (it isn't named
					// correctly)
<span class="nc" id="L384">				}</span>
			}
		}
<span class="nc" id="L387">		rollOver();</span>
<span class="nc" id="L388">	}</span>
	
	/**
	   * Compresses the passed file to a .zip file, stores the .zip in the
	   * same directory as the passed file, and then deletes the original,
	   * leaving only the .zipped archive.
	   * @param file
	   */
	  private void zipAndDelete(File file) throws IOException
	  {
<span class="nc bnc" id="L398" title="All 2 branches missed.">	      if(!file.getName().endsWith(&quot;.zip&quot;))</span>
	      {
<span class="nc" id="L400">	            File zipFile = new File(file.getParent(), file.getName() + &quot;.zip&quot;);</span>
<span class="nc" id="L401">	            FileInputStream fis = new FileInputStream(file);</span>
<span class="nc" id="L402">	            FileOutputStream fos = new FileOutputStream(zipFile);</span>
<span class="nc" id="L403">	            ZipOutputStream zos = new ZipOutputStream(fos);</span>
<span class="nc" id="L404">	            ZipEntry zipEntry = new ZipEntry(file.getName());</span>
<span class="nc" id="L405">	            zos.putNextEntry(zipEntry);</span>
	            
<span class="nc" id="L407">	            byte[] buffer = new byte[4096];</span>
	            while(true)
	            {
<span class="nc" id="L410">	                int bytesRead = fis.read(buffer);</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">	                if(bytesRead == -1) break;</span>
	                else
	                {
<span class="nc" id="L414">	                    zos.write(buffer, 0, bytesRead);</span>
	                }
<span class="nc" id="L416">	            }</span>
<span class="nc" id="L417">	            zos.closeEntry();</span>
<span class="nc" id="L418">	            fis.close();</span>
<span class="nc" id="L419">	            zos.close();</span>
<span class="nc" id="L420">	            file.delete();</span>
	      }
<span class="nc" id="L422">	  }</span>

	class StartsWithFileFilter implements FileFilter
	{
		private String startsWith;
<span class="nc" id="L427">		private boolean inclDirs = false;</span>

		/**
	     * 
	     */
		public StartsWithFileFilter(String startsWith,
				boolean includeDirectories)
<span class="nc" id="L434">		{</span>
<span class="nc" id="L435">			super();</span>
<span class="nc" id="L436">			this.startsWith = startsWith.toUpperCase();</span>
<span class="nc" id="L437">			inclDirs = includeDirectories;</span>
<span class="nc" id="L438">		}</span>

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.io.FileFilter#accept(java.io.File)
		 */
		public boolean accept(File pathname)
		{
<span class="nc bnc" id="L447" title="All 4 branches missed.">			if (!inclDirs &amp;&amp; pathname.isDirectory())</span>
			{
<span class="nc" id="L449">				return false;</span>
			} else
<span class="nc" id="L451">				return pathname.getName().toUpperCase().startsWith(startsWith);</span>
		}
	}
}

/**
 * RollingCalendar is a helper class to DailyRollingFileAppender. Given a
 * periodicity type and the current time, it computes the start of the next
 * interval.
 * */
class RollingCalendar extends GregorianCalendar
{
	private static final long serialVersionUID = -3560331770601814177L;

<span class="nc" id="L465">	int type = CustodianDailyRollingFileAppender.TOP_OF_TROUBLE;</span>

	RollingCalendar()
	{
<span class="nc" id="L469">		super();</span>
<span class="nc" id="L470">	}</span>

	RollingCalendar(TimeZone tz, Locale locale)
	{
<span class="nc" id="L474">		super(tz, locale);</span>
<span class="nc" id="L475">	}</span>

	void setType(int type)
	{
<span class="nc" id="L479">		this.type = type;</span>
<span class="nc" id="L480">	}</span>

	public long getNextCheckMillis(Date now)
	{
<span class="nc" id="L484">		return getNextCheckDate(now).getTime();</span>
	}

	public Date getNextCheckDate(Date now)
	{
<span class="nc" id="L489">		this.setTime(now);</span>

<span class="nc bnc" id="L491" title="All 7 branches missed.">		switch (type)</span>
		{
		case CustodianDailyRollingFileAppender.TOP_OF_MINUTE:
<span class="nc" id="L494">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L495">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L496">			this.add(Calendar.MINUTE, 1);</span>
<span class="nc" id="L497">			break;</span>
		case CustodianDailyRollingFileAppender.TOP_OF_HOUR:
<span class="nc" id="L499">			this.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L500">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L501">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L502">			this.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L503">			break;</span>
		case CustodianDailyRollingFileAppender.HALF_DAY:
<span class="nc" id="L505">			this.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L506">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L507">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L508">			int hour = get(Calendar.HOUR_OF_DAY);</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">			if (hour &lt; 12)</span>
			{
<span class="nc" id="L511">				this.set(Calendar.HOUR_OF_DAY, 12);</span>
			} else
			{
<span class="nc" id="L514">				this.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L515">				this.add(Calendar.DAY_OF_MONTH, 1);</span>
			}
<span class="nc" id="L517">			break;</span>
		case CustodianDailyRollingFileAppender.TOP_OF_DAY:
<span class="nc" id="L519">			this.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L520">			this.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L521">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L522">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L523">			this.add(Calendar.DATE, 1);</span>
<span class="nc" id="L524">			break;</span>
		case CustodianDailyRollingFileAppender.TOP_OF_WEEK:
<span class="nc" id="L526">			this.set(Calendar.DAY_OF_WEEK, getFirstDayOfWeek());</span>
<span class="nc" id="L527">			this.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L528">			this.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L529">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L530">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L531">			this.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc" id="L532">			break;</span>
		case CustodianDailyRollingFileAppender.TOP_OF_MONTH:
<span class="nc" id="L534">			this.set(Calendar.DATE, 1);</span>
<span class="nc" id="L535">			this.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L536">			this.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L537">			this.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L538">			this.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L539">			this.add(Calendar.MONTH, 1);</span>
<span class="nc" id="L540">			break;</span>
		default:
<span class="nc" id="L542">			throw new IllegalStateException(&quot;Unknown periodicity type.&quot;);</span>
		}
<span class="nc" id="L544">		return getTime();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>