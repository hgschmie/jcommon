<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractLongTupleList.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">collections</a> &gt; <a href="index.html" class="el_package">com.facebook.collections.specialized</a> &gt; <span class="el_source">AbstractLongTupleList.java</span></div><h1>AbstractLongTupleList.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.collections.specialized;



import com.facebook.collections.specialized.LongTupleHeap;

import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.NoSuchElementException;

/**
 * List of long-tuples that are sorted by their first element in ascending order.
 * The first element may not be negative, but subsequent ones may be.
 *
 * The list will have an initial amount of space allocated according to initialListSize, but
 * will grow/shrink as items are added and removed
 *
 */

public abstract class AbstractLongTupleList implements LongTupleHeap {
  private static final int SORT_INDEX = 0;
  private static final int DEFAULT_INITIAL_LIST_SIZE = 1; // size in tuples
  private static final int DEFAULT_TUPLE_SIZE = 2;
  private static final int ALLOCATION_CHUNK_SIZE = 1; // size in tuples
  private static final int EMPTY = -1; // sentinel to indicate empty

  private long[] tuples;
<span class="pc" id="L44">  private volatile int size = 0; // in # of tuples</span>

  /**
   *
   * @param initialListSize initial number of tuples for which to allocate spacee
   * @param tupleSize
   */
<span class="fc" id="L51">  protected AbstractLongTupleList(int initialListSize, int tupleSize) {</span>
<span class="fc" id="L52">    this.tuples = new long[initialListSize * tupleSize];</span>
<span class="fc" id="L53">    Arrays.fill(tuples, EMPTY);</span>
<span class="fc" id="L54">    setHeadIndex(0);</span>
<span class="fc" id="L55">  }</span>
  
<span class="nc" id="L57">  protected AbstractLongTupleList(long[] tuples, int size) {</span>
<span class="nc" id="L58">    this.tuples = tuples;</span>
<span class="nc" id="L59">    this.size = size;</span>
<span class="nc" id="L60">  }</span>

<span class="nc" id="L62">  public AbstractLongTupleList(AbstractLongTupleList otherTupleList) {</span>
    // we want a consistent view of otherTupleList, so synchronize on it
<span class="nc" id="L64">    synchronized (otherTupleList) {</span>
<span class="nc bnc" id="L65" title="All 2 branches missed.">      if (getTupleSize() != otherTupleList.getTupleSize()) {</span>
<span class="nc" id="L66">        throw new IllegalArgumentException(</span>
          String.format(
            &quot;mismatched tuple sizes: [%d] and [%d]&quot;,
            getTupleSize(),
            otherTupleList.getTupleSize()
          )
        );
      }
<span class="nc" id="L74">      tuples = Arrays.copyOf(otherTupleList.tuples, otherTupleList.tuples.length);</span>
<span class="nc" id="L75">      size = otherTupleList.size;</span>
<span class="nc" id="L76">    }</span>
<span class="nc" id="L77">  }</span>

  /**
   * must not refer to 'this' at all; should return a constant, or value computed on other
   * well-formed objects
   *
   * @return
   */
  protected abstract int getTupleSize();

  /**
   * creates a new heap
   * @return
   */
  protected abstract LongTupleHeap copyHeap(long[] tuples, int size);

  @Override
  public synchronized long[] peek() {
<span class="fc" id="L95">    return findSmallest(false);</span>
  }

  @Override
  public synchronized long[] poll() {
<span class="fc" id="L100">    return findSmallest(true);</span>
  }

  @Override
  public synchronized boolean add(long[] tuple) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    if (tuple.length != getTupleSize()) {</span>
<span class="nc" id="L106">      throw new IllegalArgumentException(String.format(&quot;tuples must be of size %d &quot;, getTupleSize()));</span>
    }

<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    if (tuple[SORT_INDEX] &lt; 0) {</span>
<span class="nc" id="L110">      throw new IllegalArgumentException(</span>
        String.format(
          &quot;tuple[%d] with value %d is not &gt;= 0 &quot;, 
          SORT_INDEX,
          tuple[SORT_INDEX]
        )
      );      
    }

<span class="fc bfc" id="L119" title="All 2 branches covered.">    if (!spaceFor(1)) {</span>
<span class="fc" id="L120">      resize();</span>
    }
    
    // returns the location we should insert at
<span class="fc" id="L124">    int insertLocation = findInsertLocation(tuple[SORT_INDEX]);</span>

<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    if (insertLocation &gt;= tuples.length) {</span>
      // means we need to insert at the end, but it's not empty
<span class="nc" id="L128">      int numShifted = getTupleSize() * leftCompact();</span>

<span class="nc" id="L130">      insertLocation -= numShifted;</span>
<span class="pc bfc" id="L131" title="All 2 branches covered.">    } else if (!isEmpty(insertLocation)) {</span>
      // we shift the tuples over by one at the insert location, and adjust our insert
      // location accordingly
<span class="fc" id="L134">      insertLocation = rightShift(insertLocation);</span>
    } // else the location is empty already

<span class="fc" id="L137">    insertAt(tuple, insertLocation);</span>
<span class="fc" id="L138">    updateHeadIndex(insertLocation);</span>

<span class="fc" id="L140">    return true;</span>
  }

  @Override
  public synchronized boolean addAll(Collection&lt;? extends long[]&gt; tuples) {
<span class="nc" id="L145">    throw new UnsupportedOperationException(&quot;not yet&quot;);</span>
  }

  @Override
  public int size() {
<span class="fc" id="L150">    return size;</span>
  }

  /**
   * @return # of long elements saved
   */
  @Override
  public synchronized int shrink() {
<span class="pc bpc" id="L158" title="1 of 4 branches missed.">    if (size == 0 || translate(size) == tuples.length) {</span>
<span class="fc" id="L159">      return 0;</span>
    }
    
<span class="fc" id="L162">    leftCompact();</span>
    
<span class="fc" id="L164">    int minSize = Math.max(1, size);</span>
<span class="fc" id="L165">    int rawSize = getTupleSize() * minSize;</span>
<span class="fc" id="L166">    int saved = tuples.length - rawSize;</span>
<span class="fc" id="L167">    long[] newTuples = new long[rawSize];</span>

<span class="pc bpc" id="L169" title="1 of 2 branches missed.">    if (size &gt; 0) {</span>
<span class="fc" id="L170">      System.arraycopy(tuples, 0, newTuples, 0, rawSize);</span>
    } else {
<span class="nc" id="L172">      Arrays.fill(newTuples, EMPTY);</span>
      // indicate the 'head' index is 0
<span class="nc" id="L174">      newTuples[0] = 0;</span>
    } 

<span class="fc" id="L177">    tuples = newTuples;</span>

<span class="fc" id="L179">    return saved;</span>
  }

  @Override
  public synchronized LongTupleHeap makeCopy() {
<span class="nc" id="L184">    return copyHeap(tuples, size);</span>
  }

  @Override
  public Iterator&lt;long[]&gt; iterator() {
<span class="fc" id="L189">    return new Iter();</span>
  }

  /**
   * moves all values left so there are no empty slots at the start
   *
   * @return # of empty slots we found t the start
   */
  private int leftCompact() {
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">    if (size == 0) {</span>
<span class="nc" id="L199">      return 0;</span>
    }
    // headIndex tells us the length of empty portion before the first non-empty location
<span class="fc" id="L202">    int headLength = getHeadIndex();</span>

<span class="pc bpc" id="L204" title="1 of 2 branches missed.">    if (headLength == 0) {</span>
<span class="fc" id="L205">      return 0;</span>
    }

<span class="nc" id="L208">    System.arraycopy(tuples, headLength, tuples, 0, translate(size));</span>

<span class="nc" id="L210">    return headLength;</span>
  }

  /**
   * moves all values left so there are no empty slots at the start. Works if there are empty gaps
   * between elements
   *
   * keeping this around for potential future tweaks if we find a sparse array makes sense
   * 
   * @return # of empty slots we found at the start of the list
   */
  private int leftCompactSparse() {
<span class="nc" id="L222">    int translatedWritePosition = 0;</span>
<span class="nc" id="L223">    int translatedReadPosition = getTupleSize();</span>
<span class="nc" id="L224">    int numProcessed = 0;</span>
<span class="nc" id="L225">    int emptySlots = 1;</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">    while (numProcessed &lt; size) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">      if (isEmpty(translatedWritePosition)) {</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">        while (isEmpty(translatedReadPosition) &amp;&amp; translatedReadPosition &lt; tuples.length) {</span>
<span class="nc" id="L230">          translatedReadPosition += getTupleSize();</span>
<span class="nc" id="L231">          emptySlots++;</span>
        }

<span class="nc bnc" id="L234" title="All 2 branches missed.">        if (translatedReadPosition &gt;= tuples.length) {</span>
<span class="nc" id="L235">          throw new IllegalStateException(</span>
            &quot;compact failed--couldn't find non-empty to copy to empty&quot;
          );
        }

<span class="nc" id="L240">        swap(translatedWritePosition, translatedReadPosition);</span>
      } 
      // invariant: after each iteration, the item at translatedWritePosition is  considered
      // processed
<span class="nc" id="L244">      numProcessed++;</span>

<span class="nc" id="L246">      translatedWritePosition += getTupleSize();</span>
<span class="nc" id="L247">      translatedReadPosition += getTupleSize();</span>
    } 

<span class="nc" id="L250">    return emptySlots;</span>
  }

  private void swap(int firstTranslatedPosition, int secondTranslatedPosition) {
<span class="nc" id="L254">    long[] tmpList = new long[getTupleSize()];</span>

<span class="nc" id="L256">    System.arraycopy(tuples, firstTranslatedPosition, tmpList, 0, getTupleSize());</span>
<span class="nc" id="L257">    System.arraycopy(tuples, secondTranslatedPosition, tuples, firstTranslatedPosition, getTupleSize());</span>
<span class="nc" id="L258">    System.arraycopy(tmpList, 0, tuples, secondTranslatedPosition, getTupleSize());</span>
<span class="nc" id="L259">  }</span>

  /**
   * finds the first slot that has a tuple &gt;= value
   *
   * @return index of the slot, or the index to the left if it's empty
   */
  private int findInsertLocation(long value) {
    // negative value at 0th slot =&gt; start index of non-empty values
<span class="fc" id="L268">    int startIndex = getHeadIndex();</span>
<span class="fc" id="L269">    int endIndex = startIndex + translate(size);</span>

    int i;
<span class="fc bfc" id="L272" title="All 2 branches covered.">    for (i = startIndex; i &lt; endIndex; i += getTupleSize()) {</span>
<span class="pc bpc" id="L273" title="2 of 6 branches missed.">      if (startIndex &gt;= getTupleSize() &amp;&amp; isEmpty(i - getTupleSize()) &amp;&amp; tuples[i] &gt;= value) {</span>
<span class="fc" id="L274">        return i - getTupleSize();</span>
      }
      
<span class="pc bpc" id="L277" title="1 of 4 branches missed.">      if (isEmpty(i) || tuples[i] &gt;= value) {</span>
<span class="fc" id="L278">        break;</span>
      }
    }

<span class="fc" id="L282">    return i;</span>
  }

  /**
   * invariant: there is an empty slot at the position returned. This method will call
   * leftCompact() if it needs to in order to make room for any right-shifts needed
   *
   * @param start
   */
  private int rightShift(int start) {
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">    if (!isEmpty(tuples.length - getTupleSize())) {</span>
<span class="nc" id="L293">      int numShifted = getTupleSize() * leftCompact();</span>

<span class="nc" id="L295">      start -= numShifted;</span>
    }
    
    // last index of last tuple
<span class="fc" id="L299">    int endIndex = getHeadIndex() + translate(size) - 1;</span>
    // right-shift by;  [start, endIndex] (inclusive)
<span class="fc" id="L301">    System.arraycopy(tuples, start, tuples, start + getTupleSize(), endIndex - start + 1);</span>

<span class="fc" id="L303">    return start;</span>
  }

  private boolean isEmpty(int position) {
<span class="fc bfc" id="L307" title="All 2 branches covered.">    return tuples[position] &lt; 0;</span>
  }

  private boolean spaceFor(int numItems) {
<span class="fc bfc" id="L311" title="All 2 branches covered.">    return translate(size - 1) + getTupleSize() * numItems &lt; tuples.length;</span>
  }

  /**
   * @param tuple              tuple to insert
   * @param translatedPosition translated translatedPosition
   */
  private void insertAt(long[] tuple, int translatedPosition) {
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    if (tuple.length != getTupleSize()) {</span>
<span class="nc" id="L320">      throw new IllegalArgumentException(String.format(&quot;tuples must be of size %d &quot;, getTupleSize()));</span>
    }

<span class="fc" id="L323">    int i = 0;</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">    for (long item : tuple) {</span>
<span class="fc" id="L326">      tuples[translatedPosition + i] = item;</span>
<span class="fc" id="L327">      i++;</span>
    }

<span class="fc" id="L330">    size++;</span>
<span class="fc" id="L331">  }</span>

  private void resize() {
<span class="fc" id="L334">    int newSize = getTupleSize() * (size + ALLOCATION_CHUNK_SIZE);</span>
<span class="fc" id="L335">    long[] replacement = new long[newSize];</span>

<span class="fc" id="L337">    System.arraycopy(tuples, 0, replacement, 0, tuples.length);</span>
<span class="fc" id="L338">    Arrays.fill(replacement, tuples.length, replacement.length, EMPTY);</span>
<span class="fc" id="L339">    tuples = replacement;</span>
<span class="fc" id="L340">  }</span>

  private long[] findSmallest(boolean remove) {
<span class="pc bpc" id="L343" title="1 of 2 branches missed.">    if (size == 0) {</span>
<span class="nc" id="L344">      return null;</span>
    }

<span class="fc" id="L347">    int headIndex = getHeadIndex();</span>
<span class="fc" id="L348">    long[] tupleAt = getTupleAt(headIndex);</span>

<span class="fc bfc" id="L350" title="All 2 branches covered.">    if (remove) {</span>
      // mark this as empty
<span class="fc" id="L352">      tuples[headIndex] = EMPTY;</span>
      // and set the head pointer
<span class="fc" id="L354">      setHeadIndex(headIndex + getTupleSize());</span>
<span class="fc" id="L355">      size--;</span>
    }

<span class="fc" id="L358">    return tupleAt;</span>
  }

  private int getHeadIndex() {
    // the first element is overloaded to be a pointer to the head of the non-empty segment
    // of the tuples when it is negative
<span class="fc bfc" id="L364" title="All 2 branches covered.">    if (tuples[0] &lt; 0) {</span>
<span class="fc" id="L365">      return (int) (-1 * tuples[0]);</span>
    } else {
<span class="fc" id="L367">      return 0;</span>
    }
  }

  private void setHeadIndex(int index) {
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    if (tuples[0] &lt; 0) {</span>
<span class="fc" id="L373">      tuples[0] = -index;</span>
    } else {
<span class="nc" id="L375">      throw new IllegalStateException(</span>
        String.format(&quot;trying to set head index when not empty. value: %d&quot;, tuples[0])
      );
    }
<span class="fc" id="L379">  }</span>

  /**
   * reads the current head index and updates if the new one is smaller
   * 
   * @param insertLocation
   */
  private void updateHeadIndex(int insertLocation) {
<span class="fc" id="L387">    int headIndex = getHeadIndex();</span>

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">    if (headIndex &gt; insertLocation) {</span>
<span class="nc" id="L390">      setHeadIndex(insertLocation);</span>
    }
<span class="fc" id="L392">  }</span>

  /**
   * ex: with getTupleSize()=2, and position 3, this returns 6
   * 
   * @param position tuple position
   * @return position in flattened array 
   */
  private int translate(int position) {
<span class="fc" id="L401">    return getTupleSize() * position;</span>
  }

  private int invertTranslation(int translatedPosition) {
<span class="fc" id="L405">    return translatedPosition / getTupleSize();</span>
  }

  private long[] getTupleAt(int translatedPosition) {
<span class="fc" id="L409">    long[] result = new long[getTupleSize()];</span>

<span class="fc" id="L411">    System.arraycopy(tuples, translatedPosition, result, 0, getTupleSize());</span>

<span class="fc" id="L413">    return result;</span>
  }

<span class="fc" id="L416">  private class Iter implements Iterator&lt;long[]&gt; {</span>
<span class="fc" id="L417">    private int position = getHeadIndex() / getTupleSize();</span>
<span class="fc" id="L418">    private long[] nextValue = null;</span>

    @Override
    public boolean hasNext() {
<span class="fc" id="L422">      boolean hasNext = true;</span>

<span class="fc" id="L424">      synchronized (AbstractLongTupleList.this) {</span>
<span class="fc bfc" id="L425" title="All 2 branches covered.">        if (nextValue == null) {</span>
<span class="fc" id="L426">          int translatedPosition = translate(position);</span>
<span class="fc" id="L427">          int translatedSize = translate(size);</span>

<span class="pc bpc" id="L429" title="1 of 4 branches missed.">          while (translatedPosition &lt; translatedSize &amp;&amp; isEmpty(translatedPosition)) {</span>
<span class="nc" id="L430">            translatedPosition += getTupleSize();</span>
          }

<span class="fc bfc" id="L433" title="All 2 branches covered.">          hasNext = translatedPosition &lt; translatedSize;</span>

<span class="fc bfc" id="L435" title="All 2 branches covered.">          if (hasNext) {</span>
<span class="fc" id="L436">            position = invertTranslation(translatedPosition);</span>
<span class="fc" id="L437">            nextValue = getTupleAt(translatedPosition);</span>
          }
        }
<span class="pc" id="L440">      }</span>

<span class="fc" id="L442">      return hasNext;</span>
    }

    @Override
    public long[] next() {
<span class="fc" id="L447">      synchronized (AbstractLongTupleList.this) {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">        if (!hasNext()) {</span>
<span class="nc" id="L449">          throw new NoSuchElementException(</span>
            String.format(
              &quot;position: %d, nextValue %s&quot;, position, nextValue
            )
          );
        }

<span class="fc" id="L456">        position++;</span>

<span class="fc" id="L458">        long[] result = nextValue;</span>
        // null out nextValue so hasNext() will fill it in
<span class="fc" id="L460">        nextValue = null;</span>

<span class="fc" id="L462">        return result;</span>
<span class="nc" id="L463">      }</span>
    }

    @Override
    public void remove() {
<span class="nc" id="L468">      throw new UnsupportedOperationException(&quot;remove not supported; read-only&quot;);</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>