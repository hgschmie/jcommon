<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SampledSetImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">collections</a> &gt; <a href="index.html" class="el_package">com.facebook.collections.specialized</a> &gt; <span class="el_source">SampledSetImpl.java</span></div><h1>SampledSetImpl.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.collections.specialized;

import com.facebook.collections.SetFactory;
import com.facebook.collections.WrappedIterator;
import com.facebook.logging.Logger;
import com.facebook.logging.LoggerImpl;
import com.facebook.util.digest.DigestFunction;
import com.facebook.util.serialization.SerDe;
import com.facebook.util.serialization.SerDeException;
import com.google.common.collect.ImmutableSet;

import java.io.DataInput;
import java.io.DataOutput;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Thread-safe implementation of SampledSet
 * http://algo.inria.fr/flajolet/Publications/Slides/aofa07.pdf
 * section 2.1 Adaptive Sampling
 *
 * @param &lt;T&gt; type of element in the set
 */
// TODO : optimize concurrency if proves to be a bottleneck
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">public class SampledSetImpl&lt;T&gt; implements SampledSet&lt;T&gt; {</span>
<span class="fc" id="L47">  private static final Logger LOG = LoggerImpl.getLogger(SampledSetImpl.class);</span>

  private final DigestFunction&lt;T&gt; digestFunction;
  private final SetFactory&lt;T, SnapshotableSet&lt;T&gt;&gt; setFactory;
  private final int maxSetSize;
<span class="fc" id="L52">  private final AtomicInteger proposedSize = new AtomicInteger(0);</span>
  // this protects baseSet and currentSampleRate; writeLock is held to
  // safely perform downsampling or downsample + add().  add() and copy
  // operations also need the read lock
<span class="fc" id="L56">  private final ReadWriteLock downSampleLock = new ReentrantReadWriteLock();</span>
<span class="fc" id="L57">  private final AtomicBoolean dirty = new AtomicBoolean(false);</span>

  private volatile SnapshotableSet&lt;T&gt; baseSet;
  // if md5 % sampleRate == 0, we will keep the value
  private volatile int currentSampleRate;

  // ideally, this would be private, but HashDistinctCountAggregation needs it to convert legacy
  // SampledSetImpl&lt;Long&gt; to SampledSetImpl&lt;Integer&gt;
  @Deprecated
  public SampledSetImpl(
    int maxSetSize,
    DigestFunction&lt;T&gt; digestFunction,
    SnapshotableSet&lt;T&gt; baseSet,
    SetFactory&lt;T, SnapshotableSet&lt;T&gt;&gt; setFactory,
    int currentSampleRate
<span class="fc" id="L72">  ) {</span>
<span class="fc" id="L73">    this.maxSetSize = maxSetSize;</span>
<span class="fc" id="L74">    this.digestFunction = digestFunction;</span>
<span class="fc" id="L75">    this.setFactory = setFactory;</span>
<span class="fc" id="L76">    this.baseSet = baseSet;</span>
<span class="fc" id="L77">    this.currentSampleRate = currentSampleRate;</span>
<span class="fc" id="L78">    proposedSize.set(baseSet.size());</span>
<span class="fc" id="L79">  }</span>

  public SampledSetImpl(
    int maxSetSize,
    DigestFunction&lt;T&gt; digestFunction,
    SetFactory&lt;T, SnapshotableSet&lt;T&gt;&gt; setFactory
  ) {
<span class="fc" id="L86">    this(maxSetSize, digestFunction, setFactory.create(), setFactory, 1);</span>
<span class="fc" id="L87">  }</span>

  @Override
  public boolean add(T element) {
    // algorithm:
    //   1. store sample rate
    //   2. check if element is in in sample
    //   3. increment proposed size
    //   4. if &gt;= max, grab writeLock, downsample, re-check if in sample,
    //      and add to set if in sample;
    //   5. if &lt; max, grab read lock. if sample rate changed, re-check if in
    //      sample. add if still in sample or rate hasn't changed
    //   6. either case, decrement proposed size if element ends up
    //     not being added
    //   7. release read or write lock
<span class="fc" id="L102">    boolean returnValue = false;</span>
<span class="fc" id="L103">    long elementDigest = digestFunction.computeDigest(element);</span>
<span class="fc" id="L104">    int sampleRateSnapshot = currentSampleRate;</span>

    // is this value in our current sample
<span class="fc bfc" id="L107" title="All 2 branches covered.">    if (inSample(elementDigest, sampleRateSnapshot)) {</span>
      // check if we will exceed the max size
<span class="fc bfc" id="L109" title="All 2 branches covered.">      if (proposedSize.incrementAndGet() &gt; maxSetSize) {</span>
        // then acquire writeLock and perform downsample + add while holding
        // the writeLock
<span class="fc" id="L112">        downSampleLock.writeLock().lock();</span>

        try {
<span class="pc bpc" id="L115" title="1 of 4 branches missed.">          if (inSample(elementDigest, currentSampleRate) &amp;&amp; !baseSet.contains(element)) {</span>
            // adding something new
<span class="fc" id="L117">            downSample();</span>
            // need to add while we hold the lock to guarantee we don't exceed
            // the max
<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (inSample(elementDigest, currentSampleRate)) {</span>
<span class="fc" id="L121">              returnValue = baseSet.add(element);</span>
            }
          }
        } finally {
<span class="pc bpc" id="L125" title="2 of 4 branches missed.">          if (!returnValue) {</span>
<span class="pc" id="L126">            proposedSize.decrementAndGet();</span>
          }

<span class="pc" id="L129">          downSampleLock.writeLock().unlock();</span>
<span class="fc" id="L130">        }</span>
      } else {
        // we won't exceed max size; make sure the sample rate holds constant
        // and add to the set
<span class="fc" id="L134">        downSampleLock.readLock().lock();</span>

        try {
          // we only need to check if this element is in the sample again if
          // currentSampleRate has changed
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">          if (currentSampleRate == sampleRateSnapshot ||</span>
            inSample(elementDigest, currentSampleRate)) {
<span class="fc" id="L141">            returnValue = baseSet.add(element);</span>
          }
        } finally {
<span class="pc bpc" id="L144" title="2 of 4 branches missed.">          if (!returnValue) {</span>
<span class="pc" id="L145">            proposedSize.decrementAndGet();</span>
          }

<span class="pc" id="L148">          downSampleLock.readLock().unlock();</span>
<span class="fc" id="L149">        }</span>
      }
    }

<span class="fc bfc" id="L153" title="All 2 branches covered.">    if (returnValue) {</span>
<span class="fc" id="L154">      dirty.set(true);</span>
    }

<span class="fc" id="L157">    return returnValue;</span>
  }

  private boolean inSample(long digest, int sampleRate) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">    return digest % sampleRate == 0;</span>
  }

  private void downSample() {
    // very unlikely, but possible that increasing the sample rate won't
    // remove a single value; so do this in a loop
<span class="fc" id="L167">    int removed = 0;</span>

<span class="fc bfc" id="L169" title="All 2 branches covered.">    while (baseSet.size() &gt;= maxSetSize) {</span>
<span class="fc" id="L170">      currentSampleRate &lt;&lt;= 1;</span>
<span class="pc bpc" id="L171" title="2 of 4 branches missed.">      assert (currentSampleRate &gt; 1);</span>

<span class="fc" id="L173">      removed += downSampleAtRate(currentSampleRate, baseSet);</span>
    }

<span class="pc bpc" id="L176" title="1 of 2 branches missed.">    if (removed &gt; 0) {</span>
<span class="fc" id="L177">      proposedSize.addAndGet(-removed);</span>
    }
<span class="fc" id="L179">  }</span>

  private int downSampleAtRate(int sampleRate, Set&lt;T&gt; set) {
<span class="fc" id="L182">    int removed = 0;</span>
<span class="fc" id="L183">    Iterator&lt;T&gt; iterator = set.iterator();</span>

<span class="fc bfc" id="L185" title="All 2 branches covered.">    while (iterator.hasNext()) {</span>
<span class="fc" id="L186">      T value = iterator.next();</span>

<span class="fc bfc" id="L188" title="All 2 branches covered.">      if (!inSample(digestFunction.computeDigest(value), sampleRate)) {</span>
<span class="fc" id="L189">        iterator.remove();</span>
<span class="fc" id="L190">        removed++;</span>
      }
<span class="fc" id="L192">    }</span>

<span class="fc" id="L194">    return removed;</span>
  }

  private SnapshotableSet&lt;T&gt; copyAtRate(int sampleRate) {
<span class="fc bfc" id="L198" title="All 2 branches covered.">    if (sampleRate &lt;= currentSampleRate) {</span>
      // make a fast copy
<span class="fc" id="L200">      return baseSet.makeSnapshot();</span>
    } else {
      // make a fast-copy and down-sample--faster to remove elements
      // than re-add them
<span class="fc" id="L204">      SnapshotableSet&lt;T&gt; target = baseSet.makeSnapshot();</span>

<span class="fc" id="L206">      downSampleAtRate(sampleRate, target);</span>

<span class="fc" id="L208">      return target;</span>
    }
  }

  @Override
  public int getMaxSetSize() {
<span class="fc" id="L214">    return maxSetSize;</span>
  }

  @Override
  public int getScaledSize() {
<span class="fc" id="L219">    return baseSet.size() * currentSampleRate;</span>
  }

  @Override
  public int getSampleRate() {
<span class="nc" id="L224">    return currentSampleRate;</span>
  }

  @Override
  public int getSize() {
<span class="fc" id="L229">    return baseSet.size();</span>
  }

  @Override
  public Set&lt;T&gt; getEntries() {
<span class="fc" id="L234">    return ImmutableSet.copyOf(baseSet);</span>
  }

  @Override
  public SampledSetSnapshot&lt;T&gt; sampleAt(int rate) {
    SnapshotableSet&lt;T&gt; setCopy;
    int setCopySampleRate;

    // grab this lock to make sure we have a consistent view of the sample rate
    // and the set;
<span class="fc" id="L244">    downSampleLock.readLock().lock();</span>

    try {
<span class="fc" id="L247">      setCopySampleRate = Math.max(rate, currentSampleRate);</span>
<span class="fc" id="L248">      setCopy = copyAtRate(setCopySampleRate);</span>
    } finally {
<span class="pc" id="L250">      downSampleLock.readLock().unlock();</span>
<span class="fc" id="L251">    }</span>

<span class="fc" id="L253">    return new SampledSetSnapshot&lt;T&gt;(setCopySampleRate, maxSetSize, setCopy);</span>
  }

  @Override
  public SampledSet&lt;T&gt; merge(SampledSet&lt;T&gt; sampledSet) {
    // fast-copy of ourself for merging
<span class="fc" id="L259">    SampledSet&lt;T&gt; mergedSampleSet = this.makeSnapshot();</span>
    // now merge sampledSet into the copy
<span class="fc" id="L261">    mergedSampleSet.mergeInPlaceWith(sampledSet);</span>
    // clear the changed status
<span class="fc" id="L263">    mergedSampleSet.hasChanged();</span>

<span class="fc" id="L265">    return mergedSampleSet;</span>
  }

  @Override
  public boolean mergeInPlaceWith(SampledSet&lt;T&gt; sampledSet) {
<span class="fc" id="L270">    boolean changed = false;</span>
    // take a snapshot of the other set at our sample rate. Note that it
    // only will use this rate if it is higher than its current sample rate
<span class="fc" id="L273">    SampledSetSnapshot&lt;T&gt; snapshot = sampledSet.sampleAt(currentSampleRate);</span>
    // grab our downSampleLock.writeLock to make sure the sampleRate doesn't
    // change while we work
<span class="fc" id="L276">    downSampleLock.writeLock().lock();</span>

    try {
      // shortcut for fast copy: we're empty, the snapshot's sample rate is
      // compatible with our sampleRate, and fits within our maxSize
<span class="pc bpc" id="L281" title="2 of 6 branches missed.">      if (currentSampleRate &lt;= snapshot.getSampleRate() &amp;&amp; baseSet.isEmpty() &amp;&amp;</span>
        maxSetSize &gt;= snapshot.getElements().size()
        ) {
        // copy the set, current sample size, and increment the version
<span class="fc" id="L285">        baseSet = snapshot.getElements();</span>
<span class="fc" id="L286">        currentSampleRate = snapshot.getSampleRate();</span>
<span class="fc" id="L287">        proposedSize.set(baseSet.size());</span>
<span class="fc" id="L288">        dirty.set(true);</span>

<span class="fc" id="L290">        return true;</span>
<span class="fc bfc" id="L291" title="All 4 branches covered.">      } else if (!snapshot.getElements().isEmpty() &amp;&amp;</span>
        snapshot.getSampleRate() &gt; currentSampleRate
        ) {
        // only downsample ourself if there are actually elements in the other
        // set to merge into ourself
<span class="fc" id="L296">        int removed = downSampleAtRate(snapshot.getSampleRate(), baseSet);</span>
<span class="pc bpc" id="L297" title="1 of 2 branches missed.">        if (removed &gt; 0) {</span>
<span class="fc" id="L298">          changed = true;</span>
<span class="fc" id="L299">          proposedSize.addAndGet(-removed);</span>
        }

<span class="fc" id="L302">        currentSampleRate = snapshot.getSampleRate();</span>
      }
    } finally {
<span class="pc" id="L305">      downSampleLock.writeLock().unlock();</span>
<span class="fc" id="L306">    }</span>

    // safe to do this outside the lock since we know our sampleRate is
    // at least as high as that of the elements we are adding
<span class="fc bfc" id="L310" title="All 2 branches covered.">    for (T element : snapshot.getElements()) {</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">      if (add(element)) {</span>
<span class="fc" id="L312">        changed = true;</span>
      }
<span class="fc" id="L314">    }</span>

<span class="fc bfc" id="L316" title="All 2 branches covered.">    if (changed) {</span>
<span class="fc" id="L317">      dirty.set(true);</span>
    }

<span class="fc" id="L320">    return changed;</span>
  }

  @Override
  public boolean hasChanged() {
<span class="fc" id="L325">    return dirty.getAndSet(false);</span>
  }

  @Override
  public Iterator&lt;T&gt; iterator() {
<span class="nc" id="L330">    return new WrappedIterator&lt;T&gt;(baseSet.iterator()) {</span>
      @Override
      public void remove() {
<span class="nc" id="L333">        super.remove();</span>
<span class="nc" id="L334">        dirty.set(true);</span>
<span class="nc" id="L335">      }</span>
    };
  }

  @Override
  public int size() {
<span class="fc" id="L341">    return getSize();</span>
  }

  @Override
  public boolean isEmpty() {
<span class="nc" id="L346">    return baseSet.isEmpty();</span>
  }

  @Override
  public boolean contains(Object o) {
<span class="nc" id="L351">    return baseSet.contains(o);</span>
  }

  @Override
  public Object[] toArray() {
<span class="nc" id="L356">    return baseSet.toArray();</span>
  }

  @Override
  public &lt;V&gt; V[] toArray(V[] a) {
<span class="nc" id="L361">    return baseSet.toArray(a);</span>
  }

  @Override
  public boolean remove(Object o) {
<span class="nc bnc" id="L366" title="All 2 branches missed.">    if (baseSet.remove(o)) {</span>
<span class="nc" id="L367">      dirty.set(true);</span>
<span class="nc" id="L368">      return true;</span>
    }

<span class="nc" id="L371">    return false;</span>
  }

  @Override
  public boolean containsAll(Collection&lt;?&gt; c) {
<span class="nc" id="L376">    return baseSet.containsAll(c);</span>
  }

  @Override
  public boolean addAll(Collection&lt;? extends T&gt; c) {
<span class="nc" id="L381">    boolean added = false;</span>

<span class="nc bnc" id="L383" title="All 2 branches missed.">    for (T item : c) {</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">      if (add(item)) {</span>
<span class="nc" id="L385">        added = true;</span>
      }
<span class="nc" id="L387">    }</span>

<span class="nc bnc" id="L389" title="All 2 branches missed.">    if (added) {</span>
<span class="nc" id="L390">      dirty.set(true);</span>
    }

<span class="nc" id="L393">    return added;</span>
  }

  @Override
  public boolean retainAll(Collection&lt;?&gt; c) {
<span class="nc bnc" id="L398" title="All 2 branches missed.">    if (baseSet.retainAll(c)) {</span>
<span class="nc" id="L399">      dirty.set(true);</span>

<span class="nc" id="L401">      return true;</span>
    }

<span class="nc" id="L404">    return false;</span>
  }

  @Override
  public boolean removeAll(Collection&lt;?&gt; c) {
<span class="nc bnc" id="L409" title="All 2 branches missed.">    if (baseSet.removeAll(c)) {</span>
<span class="nc" id="L410">      dirty.set(true);</span>

<span class="nc" id="L412">      return true;</span>
    }

<span class="nc" id="L415">    return false;</span>
  }

  @Override
  public void clear() {
<span class="nc" id="L420">    baseSet.clear();</span>

<span class="nc" id="L422">    dirty.set(true);</span>
<span class="nc" id="L423">  }</span>

  @Override
  public SampledSet&lt;T&gt; makeSnapshot() {
<span class="fc" id="L427">    return new SampledSetImpl&lt;T&gt;(</span>
      maxSetSize,
      digestFunction,
      baseSet.makeSnapshot(),
      setFactory,
      currentSampleRate
    );
  }

  @Override
  public SampledSet&lt;T&gt; makeTransientSnapshot() {
<span class="fc" id="L438">    SnapshotableSetImplFactory&lt;T&gt; cpuEfficientHashSetFactory =</span>
      new SnapshotableSetImplFactory&lt;T&gt;(new HashSetFactory&lt;T&gt;());
<span class="fc" id="L440">    SnapshotableSet&lt;T&gt; cpuEfficientHashSet = baseSet.makeTransientSnapshot();</span>

<span class="fc" id="L442">    return new SampledSetImpl&lt;T&gt;(</span>
      maxSetSize,
      digestFunction,
      cpuEfficientHashSet,
      cpuEfficientHashSetFactory,
      currentSampleRate
    );
  }

  @Override
  public boolean equals(Object o) {
<span class="nc" id="L453">    downSampleLock.writeLock().lock();</span>

    try {
<span class="nc bnc" id="L456" title="All 2 branches missed.">      if (this == o) {</span>
<span class="nc" id="L457">        return true;</span>
      }
<span class="nc bnc" id="L459" title="All 4 branches missed.">      if (o == null || getClass() != o.getClass()) {</span>
<span class="nc" id="L460">        return false;</span>
      }

<span class="nc" id="L463">      final SampledSetImpl&lt;T&gt; that = (SampledSetImpl&lt;T&gt;) o;</span>

<span class="nc bnc" id="L465" title="All 2 branches missed.">      if (currentSampleRate != that.currentSampleRate) {</span>
<span class="nc" id="L466">        return false;</span>
      }
<span class="nc bnc" id="L468" title="All 2 branches missed.">      if (maxSetSize != that.maxSetSize) {</span>
<span class="nc" id="L469">        return false;</span>
      }
<span class="nc bnc" id="L471" title="All 6 branches missed.">      if (baseSet != null ? !baseSet.equals(that.baseSet) : that.baseSet != null) {</span>
<span class="nc" id="L472">        return false;</span>
      }

<span class="nc" id="L475">      return true;</span>
    } finally {
<span class="nc" id="L477">      downSampleLock.writeLock().unlock();</span>
    }
  }

  @Override
  public int hashCode() {
<span class="nc" id="L483">    downSampleLock.writeLock().lock();</span>

    try {
<span class="nc bnc" id="L486" title="All 2 branches missed.">      int result = baseSet != null ? baseSet.hashCode() : 0;</span>

<span class="nc" id="L488">      result = 31 * result + maxSetSize;</span>
<span class="nc" id="L489">      result = 31 * result + currentSampleRate;</span>

<span class="nc" id="L491">      return result;</span>
    } finally {
<span class="nc" id="L493">      downSampleLock.writeLock().unlock();</span>
    }
  }

  public static class SerDeImpl&lt;T&gt; implements SerDe&lt;SampledSet&lt;T&gt;&gt; {
    private final SetFactory&lt;T, SnapshotableSet&lt;T&gt;&gt; setFactory;
    private final DigestFunction&lt;T&gt; digestFunction;
    private final SerDe&lt;T&gt; elementSerDe;

    public SerDeImpl(
      SetFactory&lt;T, SnapshotableSet&lt;T&gt;&gt; setFactory,
      DigestFunction&lt;T&gt; digestFunction,
      SerDe&lt;T&gt; elementSerDe
<span class="nc" id="L506">    ) {</span>
<span class="nc" id="L507">      this.setFactory = setFactory;</span>
<span class="nc" id="L508">      this.digestFunction = digestFunction;</span>
<span class="nc" id="L509">      this.elementSerDe = elementSerDe;</span>
<span class="nc" id="L510">    }</span>

    @Override
    public SampledSet&lt;T&gt; deserialize(DataInput in) throws SerDeException {
      try {
<span class="nc" id="L515">        int maxSize = in.readInt();</span>
<span class="nc" id="L516">        int sampleRate = in.readInt();</span>
<span class="nc" id="L517">        int numElements = in.readInt();</span>

<span class="nc" id="L519">        SnapshotableSet&lt;T&gt; baseSet = setFactory.create();</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">        for (int i = 0; i &lt; numElements; i++) {</span>
<span class="nc" id="L522">          baseSet.add(elementSerDe.deserialize(in));</span>
        }

<span class="nc" id="L525">        SampledSet&lt;T&gt; sampledSet = new SampledSetImpl&lt;T&gt;(</span>
          maxSize, digestFunction, baseSet, setFactory, sampleRate
        );

<span class="nc" id="L529">        return sampledSet;</span>
<span class="nc" id="L530">      } catch (IOException e) {</span>
<span class="nc" id="L531">        throw new SerDeException(e);</span>
      }
    }

    @Override
    public void serialize(SampledSet&lt;T&gt; value, DataOutput out)
      throws SerDeException {
      try {
        // sampling at 0 will make a copy at the existing sample rate (since the 
        // rate is only used if it is larger than the existing rate) 
<span class="nc" id="L541">        SampledSetSnapshot&lt;T&gt; snapshot = value.sampleAt(0);</span>
<span class="nc" id="L542">        Set&lt;T&gt; elements = snapshot.getElements();</span>

<span class="nc" id="L544">        out.writeInt(snapshot.getMaxSetSize());</span>
<span class="nc" id="L545">        out.writeInt(snapshot.getSampleRate());</span>
<span class="nc" id="L546">        out.writeInt(elements.size());</span>

<span class="nc bnc" id="L548" title="All 2 branches missed.">        for (T element : elements) {</span>
<span class="nc" id="L549">          elementSerDe.serialize(element, out);</span>
<span class="nc" id="L550">        }</span>

<span class="nc" id="L552">      } catch (IOException e) {</span>
<span class="nc" id="L553">        throw new SerDeException(e);</span>
<span class="nc" id="L554">      }</span>
<span class="nc" id="L555">    }</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>