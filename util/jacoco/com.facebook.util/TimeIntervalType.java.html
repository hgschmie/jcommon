<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeIntervalType.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jcommon util</a> &gt; <a href="index.html" class="el_package">com.facebook.util</a> &gt; <span class="el_source">TimeIntervalType.java</span></div><h1>TimeIntervalType.java</h1><pre class="source lang-java linenums">/*
 * Copyright (C) 2012 Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.util;

import org.joda.time.DateTime;
import org.joda.time.DateTimeField;
import org.joda.time.DateTimeFieldType;
import org.joda.time.DateTimeZone;
import org.joda.time.Duration;
import org.joda.time.DurationField;
import org.joda.time.Period;
import org.joda.time.chrono.ISOChronology;
import org.joda.time.field.FieldUtils;

/**
 * Represents a time interval type when specifying a time period. Instances of
 * this class provide means to calculate the start instant of the interval
 * containing a given time instant.
 * 
 * &lt;p&gt;
 * Each interval type computes the time interval assuming that they start 
 * from it's minimum value. For example, MINUTE represents the time interval 
 * starting from the 0th minute in the containing hour. So given a time instant
 * 2011-10-09T13:11:49, and a time interval type of MINUTE and length 3, the
 * start instant of the time interval containing that instant will be
 * 2011-10-09T13:09:00.
 * &lt;/p&gt;
 */
<span class="pc" id="L42">public enum TimeIntervalType {</span>
<span class="fc" id="L43">  MILLIS(DateTimeFieldType.millisOfSecond(), null) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L46">      return Period.millis(length);</span>
    }
  },
<span class="fc" id="L49">  SECOND(DateTimeFieldType.secondOfMinute(), MILLIS) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L52">      return Period.seconds(length);</span>
    }
  },
<span class="fc" id="L55">  MINUTE(DateTimeFieldType.minuteOfHour(), SECOND) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L58">      return Period.minutes(length);</span>
    }
  },
<span class="fc" id="L61">  HOUR(DateTimeFieldType.hourOfDay(), MINUTE) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L64">      return Period.hours(length);</span>
    }
  },
<span class="fc" id="L67">  DAY(DateTimeFieldType.dayOfMonth(), HOUR) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L70">      return Period.days(length);</span>
    }
  },
  /**
   * Week interval is currently non-intuitive. It assumes that the weeks
   * start on the same day as the first day of the year. Don't use weeks
   * as a time interval type, until we can have the weeks starting on the
   * correct day (Sunday/Monday) per the locale.
   */
<span class="fc" id="L79">  WEEK(DateTimeFieldType.weekOfWeekyear(), DAY) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L82">      return Period.weeks(length);</span>
    }
  },
<span class="fc" id="L85">  MONTH(DateTimeFieldType.monthOfYear(), DAY) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L88">      return Period.months(length);</span>
    }
  },
<span class="fc" id="L91">  YEAR(DateTimeFieldType.yearOfCentury(), MONTH) {</span>
    @Override
    public Period toPeriod(int length) {
<span class="fc" id="L94">      return Period.years(length);</span>
    }
  };

  private final DateTimeFieldType fieldType;
  private final TimeIntervalType subType;

  /**
   * Creates an instance.
   * 
   * @param type The field type corresponding to this interval type.
   * @param subType The subtype for this type.
   */
<span class="fc" id="L107">  private TimeIntervalType(DateTimeFieldType type, TimeIntervalType subType) {</span>
<span class="fc" id="L108">    this.fieldType = type;</span>
<span class="fc" id="L109">    this.subType = subType;</span>
<span class="fc" id="L110">  }</span>

  /**
   * Returns a period representing this interval type.
   * 
   * @param length the multiple of the base period unit
   * @return the period value
   */
  public abstract Period toPeriod(int length);

  /**
   * Validates that the specified interval value is valid for this 
   * interval type in the supplied time zone.
   * 
   * @param timeZone the time zone
   * @param intervalLength the interval length
   */
  public void validateValue(DateTimeZone timeZone, long intervalLength) {
<span class="fc" id="L128">    final DateTimeField field = fieldType.getField(TimeUtil.getChronology(timeZone.getID()));</span>
<span class="fc bfc" id="L129" title="All 4 branches covered.">    if (intervalLength &lt; 1</span>
      || intervalLength &gt; field.getMaximumValue()) {
<span class="fc" id="L131">      throw new IllegalArgumentException(</span>
        &quot;Supplied value &quot; + intervalLength
          + &quot; is out of bounds for &quot; + name()
      );
    }
<span class="fc" id="L136">  }</span>


  /**
   * Gets the start instant given the event instant, interval length 
   * and the time zone for this interval type.
   * 
   * @param instant the event time instant.
   * @param length the interval length
   * 
   * @return the start instant of the interval of given length that contains 
   * the supplied time instant in the supplied time zone 
   */
  public DateTime getTimeIntervalStart(
    DateTime instant,
    long length
  ) {
<span class="fc" id="L153">    validateValue(instant.getZone(), length);</span>
    // Get the time in the specified timezone
<span class="fc" id="L155">    DateTime periodStart = instant;</span>
    // Clear all the fields for this intervalType and its subtypes
<span class="fc" id="L157">    TimeIntervalType timeIntervalType = this;</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">    while (timeIntervalType != null) {</span>
<span class="fc" id="L159">      periodStart = timeIntervalType.clearField(periodStart);</span>
<span class="fc" id="L160">      timeIntervalType = timeIntervalType.subType;</span>
    }
    // figure out the which time interval does the instant lie in
<span class="fc" id="L163">    Duration duration = new Duration(periodStart, instant);</span>
<span class="fc" id="L164">    final DurationField durationField = fieldType.getField(</span>
      ISOChronology.getInstance(
        instant.getZone()
      )
    ).getDurationField();
<span class="fc" id="L169">    int diff = durationField.getValue(duration.getMillis());</span>
<span class="fc" id="L170">    long startDelta = (diff / length) * length;</span>
<span class="fc" id="L171">    return periodStart.withFieldAdded(durationField.getType(),</span>
                                      FieldUtils.safeToInt(startDelta));
  }

  /**
   * Returns the number of milliseconds per unit of this interval type.
   * 
   * @return the number of milliseconds per unit of this interval type.
   */
  public long toDurationMillis() {
<span class="fc" id="L181">    return fieldType.getDurationType().getField(</span>
      // Assume that durations are always in UTC
      ISOChronology.getInstance(DateTimeZone.UTC)).getUnitMillis();
  }

  protected DateTime clearField(DateTime value) {
<span class="fc" id="L187">    return value.withField(</span>
      fieldType,
      fieldType.getField(ISOChronology.getInstance(value.getZone()))
        .getMinimumValue()
    );
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>